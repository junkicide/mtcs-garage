// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use bincode::serialize;
use mtcs_core::*;
//use std::fs;

use rs_merkle::{algorithms::Sha256 as MerkleSha256, Hasher, MerkleTree};
use std::time::SystemTime;

use sp1_sdk::{utils, SP1Prover, SP1Stdin, SP1Verifier};

const ELF: &[u8] = include_bytes!("../../program/elf/riscv32im-succinct-zkvm-elf");

fn main() {
    utils::setup_logger();
    let start_time = SystemTime::now();

    println!("generating guest inputs...");
    // For example:
    let key: Vec<u8> = "passw0rdpassw0rdpassw0rdpassw0rd".as_bytes().to_vec();

    let secret = PrivateKey { key };
    // let cycle_data: String =  fs::read_to_string("../cycle.json").unwrap();

    // let cycle: Cycle = serde_json::from_str(&cycle_file.to_owned()).expect("JSON not well formatted");
    //    let all_obligations: Vec<Obligation> =  serde_json::from_str("obligations.json").expect("JSON was not well-formatted");

    let cycle: Cycle = Cycle {
        setoff: 103,
        size: 3,
        obligations: vec![
            Obligation {
                from: hex::decode("9BA1Bcd88E99d6E1E03252A70A63FEa83Bf1208c")
                    .expect("Decoding failed")
                    .try_into()
                    .unwrap(),
                to: hex::decode("6FF840eeeFFec0C35F52bB6031a9Ae34524a05b6")
                    .expect("Decoding failed")
                    .try_into()
                    .unwrap(),
                value: 103,
                salt: [
                    134, 104, 222, 91, 13, 97, 183, 43, 190, 29, 199, 203, 206, 17, 241, 117, 145,
                    238, 154, 201, 79, 48, 188, 175, 205, 156, 218, 223, 93, 208, 253, 13,
                ],
            },
            Obligation {
                from: hex::decode("6FF840eeeFFec0C35F52bB6031a9Ae34524a05b6")
                    .expect("Decoding failed")
                    .try_into()
                    .unwrap(),
                to: hex::decode("42cEDde51198D1773590311E2A340DC06B24cB37")
                    .expect("Decoding failed")
                    .try_into()
                    .unwrap(),
                value: 197,
                salt: [
                    47, 45, 177, 118, 3, 36, 136, 70, 238, 148, 143, 56, 140, 115, 20, 16, 235,
                    102, 188, 236, 119, 192, 25, 103, 197, 72, 237, 170, 40, 203, 125, 227,
                ],
            },
            Obligation {
                from: hex::decode("42cEDde51198D1773590311E2A340DC06B24cB37")
                    .expect("Decoding failed")
                    .try_into()
                    .unwrap(),

                to: hex::decode("9BA1Bcd88E99d6E1E03252A70A63FEa83Bf1208c")
                    .expect("Decoding failed")
                    .try_into()
                    .unwrap(),
                value: 252,
                salt: [
                    10, 136, 55, 248, 203, 115, 181, 120, 254, 162, 89, 219, 109, 241, 31, 169,
                    203, 202, 197, 34, 2, 240, 234, 36, 28, 103, 3, 184, 190, 156, 151, 252,
                ],
            },
        ],
    };

    let all_obligations: Vec<Obligation> = vec![
        Obligation {
            from: hex::decode("9BA1Bcd88E99d6E1E03252A70A63FEa83Bf1208c")
                .expect("Decoding failed")
                .try_into()
                .unwrap(),
            to: hex::decode("6FF840eeeFFec0C35F52bB6031a9Ae34524a05b6")
                .expect("Decoding failed")
                .try_into()
                .unwrap(),
            value: 103,
            salt: [
                134, 104, 222, 91, 13, 97, 183, 43, 190, 29, 199, 203, 206, 17, 241, 117, 145, 238,
                154, 201, 79, 48, 188, 175, 205, 156, 218, 223, 93, 208, 253, 13,
            ],
        },
        Obligation {
            from: hex::decode("6FF840eeeFFec0C35F52bB6031a9Ae34524a05b6")
                .expect("Decoding failed")
                .try_into()
                .unwrap(),
            to: hex::decode("42cEDde51198D1773590311E2A340DC06B24cB37")
                .expect("Decoding failed")
                .try_into()
                .unwrap(),
            value: 197,
            salt: [
                47, 45, 177, 118, 3, 36, 136, 70, 238, 148, 143, 56, 140, 115, 20, 16, 235, 102,
                188, 236, 119, 192, 25, 103, 197, 72, 237, 170, 40, 203, 125, 227,
            ],
        },
        Obligation {
            from: hex::decode("42cEDde51198D1773590311E2A340DC06B24cB37")
                .expect("Decoding failed")
                .try_into()
                .unwrap(),

            to: hex::decode("9BA1Bcd88E99d6E1E03252A70A63FEa83Bf1208c")
                .expect("Decoding failed")
                .try_into()
                .unwrap(),
            value: 252,
            salt: [
                10, 136, 55, 248, 203, 115, 181, 120, 254, 162, 89, 219, 109, 241, 31, 169, 203,
                202, 197, 34, 2, 240, 234, 36, 28, 103, 3, 184, 190, 156, 151, 252,
            ],
        },
    ];

    let mut indexes: Vec<usize> = Vec::new();
    cycle.obligations.iter().for_each(|&i| {
        let index = all_obligations.iter().position(|&x| x == i).unwrap();
        indexes.push(index)
    });

    let leaves: Vec<[u8; 32]> = all_obligations
        .iter()
        .map(|x| MerkleSha256::hash(&serialize(&x).unwrap()[..]))
        .collect();
    let len = leaves.len();

    let merkle_tree = MerkleTree::<MerkleSha256>::from_leaves(&leaves);

    let merkle_root = merkle_tree.root().ok_or("could not find root").unwrap();

    let merkle_proof = merkle_tree.proof(&indexes);

    let bytes = merkle_proof.to_bytes();

    let key: PrivateKey = secret;
    let proof: Proof = Proof {
        bytes: bytes.as_slice().try_into().unwrap(),
    };

    let aux: MerkleData = MerkleData {
        merkle_root,
        indexes: indexes.try_into().unwrap(),
        len,
    };

    let mut stdin = SP1Stdin::new();

    println!("writing inputs to guest...");
    stdin.write(&cycle);
    stdin.write(&key);
    stdin.write(&proof);
    stdin.write(&aux);

    println!("generating proof...");

    let proof = SP1Prover::prove(ELF, stdin).expect("proving failed");

    println!("proof generation completed!");

    println!("verifying receipt...");
    SP1Verifier::verify(ELF, &proof).expect("verification failed");
    println!("verification completed!");

    let end_time = SystemTime::now();
    let difference = end_time
        .duration_since(start_time)
        .expect("Clock may have gone backwards");
    println!("Total time: {difference:?}");

    proof
        .save("proof-with-io.json")
        .expect("saving proof failed");

    println!("successfully generated and verified proof for the program!")
}
