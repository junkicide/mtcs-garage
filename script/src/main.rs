// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use bincode::serialize;
use ed25519_consensus::*;
use mtcs_core::*;
use rs_merkle::{algorithms::Sha256 as MerkleSha256, Hasher, MerkleTree};
use std::fs;
use std::time::SystemTime;

use sp1_sdk::{utils, ProverClient, SP1Stdin};

const ELF: &[u8] = include_bytes!("../../program/elf/riscv32im-succinct-zkvm-elf");

fn main() {
    utils::setup_logger();
    let start_time = SystemTime::now();

    println!("generating guest inputs...");
    // For example:
    let key: Vec<u8> = "passw0rdpassw0rdpassw0rdpassw0rd".as_bytes().to_vec();

    let secret = PrivateKey { key };
    let cycle_data: String = fs::read_to_string("../cycle.json").unwrap();

    let all_obligation_data: String = fs::read_to_string("../obligations.json").unwrap();

    let cycle: Cycle =
        serde_json::from_str(&cycle_data.to_owned()).expect("JSON not well formatted");

    let all_obligations: ObligationList =
        serde_json::from_str(&all_obligation_data.to_owned()).expect("JSON not well formatted");

    let mut indexes: Vec<usize> = Vec::new();
    cycle.obligations.iter().for_each(|&i| {
        let index = all_obligations.iter().position(|&x| x == i).unwrap();
        indexes.push(index)
    });

    let leaves: Vec<[u8; 32]> = all_obligations
        .iter()
        .map(|x| MerkleSha256::hash(&serialize(&x).unwrap()[..]))
        .collect();
    let len = leaves.len();

    let merkle_tree = MerkleTree::<MerkleSha256>::from_leaves(&leaves);

    let merkle_root = merkle_tree.root().ok_or("could not find root").unwrap();

    let merkle_proof = merkle_tree.proof(&indexes);

    let bytes = merkle_proof.to_bytes();

    let key: PrivateKey = secret;
    let proof: Proof = Proof {
        bytes: bytes.as_slice().try_into().unwrap(),
    };

    let aux: MerkleData = MerkleData {
        merkle_root,
        indexes: indexes.try_into().unwrap(),
        len,
    };

    let mut stdin = SP1Stdin::new();
    let client = ProverClient::new();

    println!("writing inputs to guest...");
    stdin.write(&cycle);
    stdin.write(&key);
    stdin.write(&proof);
    stdin.write(&aux);

    println!("generating proof...");

    let mut proof = client.prove(ELF, stdin).expect("proving failed");

    println!("proof generation completed!");

    println!("verifying receipt...");
    client.verify(ELF, &proof).expect("verification failed");
    println!("verification completed!");

    println!("validating digital signature...");

    let (hash, verification_key, sign): &([u8; 32], VerificationKey, Signature) =
        &proof.public_values.read();
    // let read_values: ([u8; 32], Signature) = pub_values.read();
    let sig_verify = verification_key.verify(sign, hash).is_ok();
    assert!(sig_verify);
    let end_time = SystemTime::now();
    let difference = end_time
        .duration_since(start_time)
        .expect("Clock may have gone backwards");
    println!("Total time: {difference:?}");

    proof
        .save("proof-with-io.json")
        .expect("saving proof failed");

    println!("successfully generated and verified proof for cycle validity!")
}
